"""
Â¢ûÂº∫ÁöÑÂëΩ‰ª§ÁÆ°ÁêÜÂô® - ÈÄöËøáClaude RouterË∑ØÁî±ÂëΩ‰ª§Âà∞Claude Code Tool
Êû∂ÊûÑ: ClaudeEditor ‚Üí Claude Router ‚Üí Command MCP + Local Adapter MCP
"""

import asyncio
import json
import logging
import subprocess
from typing import Any, Dict, List, Optional, Tuple
from pathlib import Path
import os
import sys

logger = logging.getLogger(__name__)

class EnhancedCommandManager:
    """Â¢ûÂº∫ÁöÑÂëΩ‰ª§ÁÆ°ÁêÜÂô®"""
    
    def __init__(self, local_adapter=None):
        """
        ÂàùÂßãÂåñÂ¢ûÂº∫ÂëΩ‰ª§ÁÆ°ÁêÜÂô®
        
        Args:
            local_adapter: Êú¨Âú∞ÈÄÇÈÖçÂô®ÂÆû‰æã
        """
        self.local_adapter = local_adapter
        self.claude_code_executable = "claude-code"
        self.command_history: List[Dict[str, Any]] = []
        self.active_sessions: Dict[str, Any] = {}
        
        # ÂëΩ‰ª§Á±ªÂûãÊò†Â∞Ñ
        self.command_types = {
            "claude_code": self._execute_claude_code_command,
            "local_system": self._execute_local_system_command,
            "file_operation": self._execute_file_operation,
            "workflow": self._execute_workflow_command,
            "mcp_internal": self._execute_mcp_internal_command
        }
    
    async def route_command(self, command_request: Dict[str, Any]) -> Dict[str, Any]:
        """
        Ë∑ØÁî±ÂëΩ‰ª§Âà∞Áõ∏Â∫îÁöÑÊâßË°åÂô®
        
        Args:
            command_request: ÂëΩ‰ª§ËØ∑Ê±Ç
            {
                "command": "ÂÖ∑‰ΩìÂëΩ‰ª§",
                "type": "ÂëΩ‰ª§Á±ªÂûã",
                "session_id": "‰ºöËØùID",
                "parameters": {},
                "context": {}
            }
            
        Returns:
            ÂëΩ‰ª§ÊâßË°åÁªìÊûú
        """
        try:
            command_type = command_request.get("type", "claude_code")
            command = command_request.get("command", "")
            session_id = command_request.get("session_id", "default")
            
            logger.info(f"üîÑ Ë∑ØÁî±ÂëΩ‰ª§: {command_type} - {command}")
            
            # Ê£ÄÊü•ÂëΩ‰ª§Á±ªÂûã
            if command_type not in self.command_types:
                return {
                    "success": False,
                    "error": f"‰∏çÊîØÊåÅÁöÑÂëΩ‰ª§Á±ªÂûã: {command_type}",
                    "available_types": list(self.command_types.keys())
                }
            
            # ÊâßË°åÂëΩ‰ª§
            result = await self.command_types[command_type](command_request)
            
            # ËÆ∞ÂΩïÂëΩ‰ª§ÂéÜÂè≤
            self._record_command_history(command_request, result)
            
            return result
            
        except Exception as e:
            logger.error(f"‚ùå ÂëΩ‰ª§Ë∑ØÁî±Â§±Ë¥•: {e}")
            return {
                "success": False,
                "error": str(e),
                "command": command_request.get("command", "")
            }
    
    async def _execute_claude_code_command(self, command_request: Dict[str, Any]) -> Dict[str, Any]:
        """
        ÊâßË°åClaude CodeÂëΩ‰ª§
        
        Args:
            command_request: ÂëΩ‰ª§ËØ∑Ê±Ç
            
        Returns:
            ÊâßË°åÁªìÊûú
        """
        try:
            command = command_request["command"]
            parameters = command_request.get("parameters", {})
            
            # ÊûÑÂª∫ÂÆåÊï¥ÁöÑClaude CodeÂëΩ‰ª§
            if parameters.get("working_directory"):
                os.chdir(parameters["working_directory"])
            
            full_command = f"{self.claude_code_executable} {command}"
            
            # ÊâßË°åÂëΩ‰ª§
            process = await asyncio.create_subprocess_shell(
                full_command,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                cwd=parameters.get("working_directory", Path.cwd())
            )
            
            stdout, stderr = await process.communicate()
            
            result = {
                "success": process.returncode == 0,
                "return_code": process.returncode,
                "stdout": stdout.decode('utf-8', errors='ignore'),
                "stderr": stderr.decode('utf-8', errors='ignore'),
                "command": command,
                "type": "claude_code",
                "executed_at": asyncio.get_event_loop().time()
            }
            
            # ÈÄöËøáLocal AdapterÂ§ÑÁêÜÁªìÊûú
            if self.local_adapter:
                result = await self.local_adapter.process_claude_code_result(result)
            
            logger.info(f"‚úÖ Claude CodeÂëΩ‰ª§ÊâßË°åÂÆåÊàê: {command}")
            return result
            
        except Exception as e:
            logger.error(f"‚ùå Claude CodeÂëΩ‰ª§ÊâßË°åÂ§±Ë¥•: {e}")
            return {
                "success": False,
                "error": str(e),
                "command": command_request.get("command", ""),
                "type": "claude_code"
            }
    
    async def _execute_local_system_command(self, command_request: Dict[str, Any]) -> Dict[str, Any]:
        """
        ÊâßË°åÊú¨Âú∞Á≥ªÁªüÂëΩ‰ª§
        
        Args:
            command_request: ÂëΩ‰ª§ËØ∑Ê±Ç
            
        Returns:
            ÊâßË°åÁªìÊûú
        """
        try:
            command = command_request["command"]
            parameters = command_request.get("parameters", {})
            
            # ÂÆâÂÖ®Ê£ÄÊü•
            if not self._is_safe_command(command):
                return {
                    "success": False,
                    "error": "‰∏çÂÆâÂÖ®ÁöÑÂëΩ‰ª§Ë¢´ÈòªÊ≠¢",
                    "command": command,
                    "type": "local_system"
                }
            
            # ÊâßË°åÊú¨Âú∞ÂëΩ‰ª§
            process = await asyncio.create_subprocess_shell(
                command,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                cwd=parameters.get("working_directory", Path.cwd())
            )
            
            stdout, stderr = await process.communicate()
            
            result = {
                "success": process.returncode == 0,
                "return_code": process.returncode,
                "stdout": stdout.decode('utf-8', errors='ignore'),
                "stderr": stderr.decode('utf-8', errors='ignore'),
                "command": command,
                "type": "local_system",
                "executed_at": asyncio.get_event_loop().time()
            }
            
            # ÈÄöËøáLocal AdapterÂ§ÑÁêÜÁªìÊûú
            if self.local_adapter:
                result = await self.local_adapter.process_local_command_result(result)
            
            logger.info(f"‚úÖ Êú¨Âú∞Á≥ªÁªüÂëΩ‰ª§ÊâßË°åÂÆåÊàê: {command}")
            return result
            
        except Exception as e:
            logger.error(f"‚ùå Êú¨Âú∞Á≥ªÁªüÂëΩ‰ª§ÊâßË°åÂ§±Ë¥•: {e}")
            return {
                "success": False,
                "error": str(e),
                "command": command_request.get("command", ""),
                "type": "local_system"
            }
    
    async def _execute_file_operation(self, command_request: Dict[str, Any]) -> Dict[str, Any]:
        """
        ÊâßË°åÊñá‰ª∂Êìç‰ΩúÂëΩ‰ª§
        
        Args:
            command_request: ÂëΩ‰ª§ËØ∑Ê±Ç
            
        Returns:
            ÊâßË°åÁªìÊûú
        """
        try:
            operation = command_request["command"]
            parameters = command_request.get("parameters", {})
            
            if operation == "read":
                file_path = parameters.get("file_path")
                if not file_path or not Path(file_path).exists():
                    return {
                        "success": False,
                        "error": f"Êñá‰ª∂‰∏çÂ≠òÂú®: {file_path}",
                        "type": "file_operation"
                    }
                
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                return {
                    "success": True,
                    "content": content,
                    "file_path": file_path,
                    "type": "file_operation",
                    "operation": "read"
                }
            
            elif operation == "write":
                file_path = parameters.get("file_path")
                content = parameters.get("content", "")
                
                Path(file_path).parent.mkdir(parents=True, exist_ok=True)
                
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(content)
                
                return {
                    "success": True,
                    "file_path": file_path,
                    "bytes_written": len(content.encode('utf-8')),
                    "type": "file_operation",
                    "operation": "write"
                }
            
            elif operation == "list":
                directory = parameters.get("directory", ".")
                pattern = parameters.get("pattern", "*")
                
                files = list(Path(directory).glob(pattern))
                file_info = []
                
                for file_path in files:
                    if file_path.is_file():
                        file_info.append({
                            "name": file_path.name,
                            "path": str(file_path),
                            "size": file_path.stat().st_size,
                            "modified": file_path.stat().st_mtime
                        })
                
                return {
                    "success": True,
                    "files": file_info,
                    "directory": directory,
                    "pattern": pattern,
                    "type": "file_operation",
                    "operation": "list"
                }
            
            else:
                return {
                    "success": False,
                    "error": f"‰∏çÊîØÊåÅÁöÑÊñá‰ª∂Êìç‰Ωú: {operation}",
                    "type": "file_operation"
                }
                
        except Exception as e:
            logger.error(f"‚ùå Êñá‰ª∂Êìç‰ΩúÂ§±Ë¥•: {e}")
            return {
                "success": False,
                "error": str(e),
                "type": "file_operation"
            }
    
    async def _execute_workflow_command(self, command_request: Dict[str, Any]) -> Dict[str, Any]:
        """
        ÊâßË°åÂ∑•‰ΩúÊµÅÂëΩ‰ª§
        
        Args:
            command_request: ÂëΩ‰ª§ËØ∑Ê±Ç
            
        Returns:
            ÊâßË°åÁªìÊûú
        """
        try:
            workflow_type = command_request["command"]
            parameters = command_request.get("parameters", {})
            
            # ËøôÈáåÂ∞ÜÈõÜÊàêÈáçÊñ∞ÂÆö‰πâÁöÑÂÖ≠Â§ßÂ∑•‰ΩúÊµÅ
            workflow_results = {
                "goal_driven_development": await self._execute_goal_driven_workflow(parameters),
                "intelligent_code_generation": await self._execute_intelligent_code_workflow(parameters),
                "automated_testing_validation": await self._execute_automated_testing_workflow(parameters),
                "continuous_quality_assurance": await self._execute_quality_assurance_workflow(parameters),
                "smart_deployment_ops": await self._execute_smart_deployment_workflow(parameters),
                "adaptive_learning_optimization": await self._execute_adaptive_learning_workflow(parameters)
            }
            
            if workflow_type in workflow_results:
                return workflow_results[workflow_type]
            else:
                return {
                    "success": False,
                    "error": f"‰∏çÊîØÊåÅÁöÑÂ∑•‰ΩúÊµÅÁ±ªÂûã: {workflow_type}",
                    "available_workflows": list(workflow_results.keys()),
                    "type": "workflow"
                }
                
        except Exception as e:
            logger.error(f"‚ùå Â∑•‰ΩúÊµÅÊâßË°åÂ§±Ë¥•: {e}")
            return {
                "success": False,
                "error": str(e),
                "type": "workflow"
            }
    
    async def _execute_mcp_internal_command(self, command_request: Dict[str, Any]) -> Dict[str, Any]:
        """
        ÊâßË°åMCPÂÜÖÈÉ®ÂëΩ‰ª§
        
        Args:
            command_request: ÂëΩ‰ª§ËØ∑Ê±Ç
            
        Returns:
            ÊâßË°åÁªìÊûú
        """
        try:
            command = command_request["command"]
            parameters = command_request.get("parameters", {})
            
            # MCPÂÜÖÈÉ®ÂëΩ‰ª§Â§ÑÁêÜ
            if command == "status":
                return {
                    "success": True,
                    "status": "running",
                    "active_sessions": len(self.active_sessions),
                    "command_history_count": len(self.command_history),
                    "type": "mcp_internal"
                }
            
            elif command == "reset":
                self.command_history.clear()
                self.active_sessions.clear()
                return {
                    "success": True,
                    "message": "MCPÁä∂ÊÄÅÂ∑≤ÈáçÁΩÆ",
                    "type": "mcp_internal"
                }
            
            elif command == "health_check":
                health_status = await self._perform_health_check()
                return {
                    "success": True,
                    "health_status": health_status,
                    "type": "mcp_internal"
                }
            
            else:
                return {
                    "success": False,
                    "error": f"‰∏çÊîØÊåÅÁöÑMCPÂÜÖÈÉ®ÂëΩ‰ª§: {command}",
                    "type": "mcp_internal"
                }
                
        except Exception as e:
            logger.error(f"‚ùå MCPÂÜÖÈÉ®ÂëΩ‰ª§ÊâßË°åÂ§±Ë¥•: {e}")
            return {
                "success": False,
                "error": str(e),
                "type": "mcp_internal"
            }
    
    # ÂÖ≠Â§ßÂ∑•‰ΩúÊµÅÁöÑÂç†‰ΩçÁ¨¶ÂÆûÁé∞ÔºàÂ∞ÜÂú®ÂêéÁª≠ÈáçÊûÑ‰∏≠ÂÆåÂñÑÔºâ
    async def _execute_goal_driven_workflow(self, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """ÁõÆÊ†áÈ©±Âä®ÂºÄÂèëÂ∑•‰ΩúÊµÅ"""
        return {
            "success": True,
            "workflow": "goal_driven_development",
            "status": "ÊâßË°å‰∏≠",
            "message": "ÁõÆÊ†áÈ©±Âä®ÂºÄÂèëÂ∑•‰ΩúÊµÅÂ∑≤ÂêØÂä®",
            "type": "workflow"
        }
    
    async def _execute_intelligent_code_workflow(self, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Êô∫ËÉΩ‰ª£Á†ÅÁîüÊàêÂ∑•‰ΩúÊµÅ"""
        return {
            "success": True,
            "workflow": "intelligent_code_generation",
            "status": "ÊâßË°å‰∏≠",
            "message": "Êô∫ËÉΩ‰ª£Á†ÅÁîüÊàêÂ∑•‰ΩúÊµÅÂ∑≤ÂêØÂä®",
            "type": "workflow"
        }
    
    async def _execute_automated_testing_workflow(self, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Ëá™Âä®ÂåñÊµãËØïÈ™åËØÅÂ∑•‰ΩúÊµÅ"""
        return {
            "success": True,
            "workflow": "automated_testing_validation",
            "status": "ÊâßË°å‰∏≠",
            "message": "Ëá™Âä®ÂåñÊµãËØïÈ™åËØÅÂ∑•‰ΩúÊµÅÂ∑≤ÂêØÂä®",
            "type": "workflow"
        }
    
    async def _execute_quality_assurance_workflow(self, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """ÊåÅÁª≠Ë¥®Èáè‰øùËØÅÂ∑•‰ΩúÊµÅ"""
        return {
            "success": True,
            "workflow": "continuous_quality_assurance",
            "status": "ÊâßË°å‰∏≠",
            "message": "ÊåÅÁª≠Ë¥®Èáè‰øùËØÅÂ∑•‰ΩúÊµÅÂ∑≤ÂêØÂä®",
            "type": "workflow"
        }
    
    async def _execute_smart_deployment_workflow(self, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Êô∫ËÉΩÈÉ®ÁΩ≤ËøêÁª¥Â∑•‰ΩúÊµÅ"""
        return {
            "success": True,
            "workflow": "smart_deployment_ops",
            "status": "ÊâßË°å‰∏≠",
            "message": "Êô∫ËÉΩÈÉ®ÁΩ≤ËøêÁª¥Â∑•‰ΩúÊµÅÂ∑≤ÂêØÂä®",
            "type": "workflow"
        }
    
    async def _execute_adaptive_learning_workflow(self, parameters: Dict[str, Any]) -> Dict[str, Any]:
        """Ëá™ÈÄÇÂ∫îÂ≠¶‰π†‰ºòÂåñÂ∑•‰ΩúÊµÅ"""
        return {
            "success": True,
            "workflow": "adaptive_learning_optimization",
            "status": "ÊâßË°å‰∏≠",
            "message": "Ëá™ÈÄÇÂ∫îÂ≠¶‰π†‰ºòÂåñÂ∑•‰ΩúÊµÅÂ∑≤ÂêØÂä®",
            "type": "workflow"
        }
    
    def _is_safe_command(self, command: str) -> bool:
        """Ê£ÄÊü•ÂëΩ‰ª§ÊòØÂê¶ÂÆâÂÖ®"""
        dangerous_commands = [
            "rm -rf", "format", "del /", "rm /*", 
            "sudo rm", "chmod 777", "dd if=", ":(){ :|:& };:"
        ]
        
        return not any(dangerous in command.lower() for dangerous in dangerous_commands)
    
    async def _perform_health_check(self) -> Dict[str, Any]:
        """ÊâßË°åÂÅ•Â∫∑Ê£ÄÊü•"""
        try:
            # Ê£ÄÊü•Claude Code ToolÂèØÁî®ÊÄß
            claude_code_available = await self._check_claude_code_availability()
            
            # Ê£ÄÊü•Local AdapterÁä∂ÊÄÅ
            local_adapter_status = "available" if self.local_adapter else "not_configured"
            
            return {
                "overall_status": "healthy",
                "claude_code_tool": claude_code_available,
                "local_adapter": local_adapter_status,
                "command_history_size": len(self.command_history),
                "active_sessions": len(self.active_sessions),
                "timestamp": asyncio.get_event_loop().time()
            }
            
        except Exception as e:
            return {
                "overall_status": "unhealthy",
                "error": str(e),
                "timestamp": asyncio.get_event_loop().time()
            }
    
    async def _check_claude_code_availability(self) -> str:
        """Ê£ÄÊü•Claude Code ToolÂèØÁî®ÊÄß"""
        try:
            process = await asyncio.create_subprocess_shell(
                f"{self.claude_code_executable} --version",
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate()
            
            if process.returncode == 0:
                return "available"
            else:
                return "error"
                
        except Exception:
            return "not_found"
    
    def _record_command_history(self, command_request: Dict[str, Any], result: Dict[str, Any]):
        """ËÆ∞ÂΩïÂëΩ‰ª§ÂéÜÂè≤"""
        history_entry = {
            "timestamp": asyncio.get_event_loop().time(),
            "command_request": command_request,
            "result": result,
            "session_id": command_request.get("session_id", "default")
        }
        
        self.command_history.append(history_entry)
        
        # ÈôêÂà∂ÂéÜÂè≤ËÆ∞ÂΩïÂ§ßÂ∞è
        if len(self.command_history) > 1000:
            self.command_history = self.command_history[-500:]
    
    async def get_command_history(self, session_id: str = None, limit: int = 100) -> List[Dict[str, Any]]:
        """Ëé∑ÂèñÂëΩ‰ª§ÂéÜÂè≤"""
        if session_id:
            filtered_history = [
                entry for entry in self.command_history
                if entry.get("session_id") == session_id
            ]
        else:
            filtered_history = self.command_history
        
        return filtered_history[-limit:]
    
    async def clear_command_history(self, session_id: str = None):
        """Ê∏ÖÁ©∫ÂëΩ‰ª§ÂéÜÂè≤"""
        if session_id:
            self.command_history = [
                entry for entry in self.command_history
                if entry.get("session_id") != session_id
            ]
        else:
            self.command_history.clear()
        
        logger.info(f"üìù ÂëΩ‰ª§ÂéÜÂè≤Â∑≤Ê∏ÖÁ©∫ - ‰ºöËØù: {session_id or 'all'}")

# ‰ΩøÁî®Á§∫‰æã
async def main():
    """‰∏ªÂáΩÊï∞Á§∫‰æã"""
    command_manager = EnhancedCommandManager()
    
    # Á§∫‰æãÂëΩ‰ª§ËØ∑Ê±Ç
    command_request = {
        "command": "--version",
        "type": "claude_code",
        "session_id": "test_session",
        "parameters": {},
        "context": {}
    }
    
    result = await command_manager.route_command(command_request)
    print(json.dumps(result, indent=2, ensure_ascii=False))

if __name__ == "__main__":
    asyncio.run(main())